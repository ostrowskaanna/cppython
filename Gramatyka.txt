"comparator" = ('LESS'|'LESS_EQUAL'|'GREATER'|'GREATER_EQUAL'|'EQUAL_EQUAL'|'NOT_EQUAL')

"operator" = ('PLUS'|'MINUS'|'MULTIPLY'|'DIVIDE')

"type" = ('INT'|'CHAR'|'STRING'|'BOOL'|'FLOAT'|'LONG'|'SHORT')

"string_value" = (" )

"number" = ('INT_NUMBER'|'FLOAT_NUMBER')

"bool_values" = ('TRUE'|'FALSE')

"value" = ("number"|"bool_values"|'VAR'|"get_array_element")

"increment" = ('VAR' 'PLUS_PLUS' 'SEMICOLON')

"decrement" = ('VAR' 'MINUS_MINUS' 'SEMICOLON')

"get_array_element" = ('VAR' 'LEFT_BR_SQUARED' 'INT_NUMBER' 'RIGHT_BR_SQUARED')

"operation" = ("increment"'SEMICOLON'|"decrement"'SEMICOLON'|"value" "operator" "value" 'SEMICOLON')

"assignment" = ('VAR' 'EQUAL' "value" 'SEMICOLON')

"var_declaration" = ("type" 'VAR' 'SEMICOLON')

"comparision" = ("number" "comparator" "number")|('VAR' 'EQUAL' 'TRUE'|'FALSE')

"returning" = ('RETURN' "value" 'SEMICOLON')

"null" = ' '

"instructions" = ("loop"|"if_statement"|"assigment"|"operation") ---> nie wiem czy mogę tu użyć *

"class_defintion" = ('CLASS' 'STRING' 'LEFT_BR_CURLY' ('PUBLIC'|'PRIVATE'|'PROTECTED') 'COLON' ("var_declaration"|"function_definition")* 'RIGHT_BR_CURLY' 'SEMICOLON')

"function_definition" = ("type"|'VOID' 'STRING' 'LEFT_BR' (("type" 'VAR')|"null") 'RIGHT_BR' 'LEFT_BR_CURLY' ("instructions"|"if_statement"*|"while_loop"*) 'RIGHT_BR_CURLY')

"else_statement" = ('ELSE' 'LEFT_BR_CURLY' "instructions" 'RIGHT_BR_CURLY')

"if_statement" = ('IF' 'LEFT_BR' "comparision" 'RIGHT_BR' 'LEFT_BR_CURLY' "instructions" 'RIGHT_BR_CURLY' ("else_statement"|"null"))

"while_loop" = ('WHILE' 'LEFT_BR' "comparision" 'RIGHT_BR' 'LEFT_BR_CURLY' "instructions" 'RIGHT_BR_CURLY')

"for_loop" = 

"loop" = ("while_loop"|"for_loop")

"using_namespace_std" = ('USING' 'NAMESPACE' 'STD' 'SEMICOLON')

"include" = ('HASH' 'INCLUDE' 'LESS' 'VAR' 'GREATER') ---> nie wiemm czy VAR tu jest ok chodzi mi o słowo po prostu

PYTAJNIKI: 
1) w operation jest coś nie tak z inkre/dekrementacją chyba powinny być zamiast nich same ++ i -- dane albo nie kumam
2) po co nam token "endl" jak "cin" i "cout" nie definiowaliśmy 
